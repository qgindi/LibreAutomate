#pragma warning disable 1591 //missing XML documentation

namespace Au {
	/// <summary>
	/// Gets known/special folder paths (Desktop, Temp, etc).
	/// </summary>
	/// <remarks>
	/// Most functions return <see cref="FolderPath"/>, not <c>string</c>. It is implicitly convertible to <c>string</c>. Its operator <c>+</c> appends a filename or relative path string, with <c>\</c> separator if need. Example:
	/// 
	/// <code><![CDATA[string s = folders.Desktop + "file.txt"; //C:\Users\Name\Desktop\file.txt]]></code>
	/// 
	/// If a function cannot get folder path, the return value contains <c>null</c> string. Then the <c>+</c> operator would throw <see cref="ArgumentException"/>.
	///
	/// Some folders are known only on newer Windows versions or only on some computers. Some functions have a suffix like <c>_Win8</c> which means that the folder is unavailable on older Windows.
	/// Some known folders, although supported and registered, may be still not created.
	/// 
	/// Some folders are virtual, for example Control Panel. They don't have a file system path, but can be identified by a data structure <ms>ITEMIDLIST</ms>. Functions of the nested class <see cref="shell"/> return it as <see cref="Pidl"/> or string <c>":: ITEMIDLIST"</c> that can be used with some functions of this library (<see cref="run.it"/>, <see cref="icon.of"/>, <see cref="icon.ofPidl(Pidl, int)"/>) but not with .NET functions.
	///
	/// Most functions use Windows "Known Folders" API, such as <ms>SHGetKnownFolderPath</ms>.
	/// The list of Windows predefined known folders: <ms>KNOWNFOLDERID</ms>.
	/// Names of folders specific to current process have prefix <c>This</c>, like <c>ThisApp</c>.
	/// 
	/// Some paths depend on the bitness (32 or 64 bit) of the OS and this process.
	/// <table>
	/// <tr>
	/// <td>32-bit Windows</td>
	/// <td>
	/// <c>System</c>, <c>SystemX86</c>, <c>SystemX64</c>: <c>@"C:\WINDOWS\system32"</c>
	/// <br/><c>ProgramFiles</c>, <c>ProgramFilesX86</c>, <c>ProgramFilesX64</c>: <c>@"C:\Program Files"</c>
	/// <br/><c>ProgramFilesCommon</c>, <c>ProgramFilesCommonX86</c>, <c>ProgramFilesCommonX64</c>: <c>@"C:\Program Files\Common Files"</c>
	/// </td>
	/// </tr>
	/// <tr>
	/// <td>64-bit Windows, 64-bit process</td>
	/// <td>
	/// <c>System</c>, <c>SystemX64</c>: <c>@"C:\WINDOWS\system32"</c>
	/// <br/><c>SystemX86</c>: <c>@"C:\WINDOWS\SysWOW64"</c>
	/// <br/><c>ProgramFiles</c>, <c>ProgramFilesX64</c>: <c>@"C:\Program Files"</c>
	/// <br/><c>ProgramFilesX86</c>: <c>@"C:\Program Files (x86)"</c>
	/// <br/><c>ProgramFilesCommon</c>, <c>ProgramFilesCommonX64</c>: <c>@"C:\Program Files\Common Files"</c>
	/// <br/><c>ProgramFilesCommonX86</c>: <c>@"C:\Program Files (x86)\Common Files"</c>
	/// </td>
	/// </tr>
	/// <tr>
	/// <td>64-bit Windows, 32-bit process</td>
	/// <td>
	/// <c>System</c>: <c>@"C:\WINDOWS\system32"</c>. However the OS in most cases redirects this path to <c>@"C:\WINDOWS\SysWOW64"</c>.
	/// <br/><c>SystemX86</c>: <c>@"C:\WINDOWS\SysWOW64"</c>
	/// <br/><c>SystemX64</c>: <c>@"C:\WINDOWS\Sysnative"</c>. The OS redirects it to the true <c>@"C:\WINDOWS\system32"</c>. It is a special path, not in Explorer.
	/// <br/><c>ProgramFiles</c>, <c>ProgramFilesX86</c>: <c>@"C:\Program Files (x86)"</c>
	/// <br/><c>ProgramFilesX64</c>: <c>@"C:\Program Files"</c>
	/// <br/><c>ProgramFilesCommon</c>, <c>ProgramFilesCommonX86</c>: <c>@"C:\Program Files (x86)\Common Files"</c>
	/// <br/><c>ProgramFilesCommonX64</c>: <c>@"C:\Program Files\Common Files"</c>
	/// </td>
	/// </tr>
	/// </table>
	/// </remarks>
	public static class folders {
		#region generated by macro "Auto create special folders class from KNOWNFOLDERID"
		
		public static FolderPath AccountPictures_Win8 => _Get(0x008ca0b1, 0x55b44c56, 0xb8a84de4, 0xb299d3be);
		public static FolderPath AdminTools => _Get(0x724EF170, 0xA42D4FEF, 0x9F26B60E, 0x846FBA4F);
		public static FolderPath ApplicationShortcuts_Win8 => _Get(0xA3918781, 0xE5F24890, 0xB3D9A7E5, 0x4332328C);
		public static FolderPath CameraRoll_Win81 => _Get(0xAB5FB87B, 0x7CE24F83, 0x915D5508, 0x46C9537B);
		public static FolderPath CDBurning => _Get(0x9E52AB10, 0xF80D49DF, 0xACB84330, 0xF5687855);
		public static FolderPath CommonAdminTools => _Get(0xD0384E7D, 0xBAC34797, 0x8F14CBA2, 0x29B392B5);
		public static FolderPath CommonOEMLinks => _Get(0xC1BAE2D0, 0x10DF4334, 0xBEDD7AA2, 0x0B227A9D);
		public static FolderPath CommonPrograms => _Get(0x0139D44E, 0x6AFE49F2, 0x86903DAF, 0xCAE6FFB8);
		public static FolderPath CommonStartMenu => _Get(0xA4115719, 0xD62E491D, 0xAA7CE74B, 0x8BE3B067);
		public static FolderPath CommonStartup => _Get(0x82A5EA35, 0xD9CD47C5, 0x9629E15D, 0x2F714E6E);
		public static FolderPath CommonTemplates => _Get(0xB94237E7, 0x57AC4347, 0x9151B08C, 0x6C32D1F7);
		public static FolderPath Contacts => _Get(0x56784854, 0xC6CB462b, 0x816988E3, 0x50ACB882);
		public static FolderPath Cookies => _Get(0x2B0F765D, 0xC0E94171, 0x908E08A6, 0x11B84FF6);
		public static FolderPath Desktop => _Get(0xB4BFCC3A, 0xDB2C424C, 0xB0297FE9, 0x9A87C641);
		public static FolderPath DeviceMetadataStore => _Get(0x5CE4A5E9, 0xE4EB479D, 0xB89F130C, 0x02886155);
		public static FolderPath Documents => _Get(0xFDD39AD0, 0x238F46AF, 0xADB46C85, 0x480369C7);
		public static FolderPath DocumentsLibrary => _Get(0x7B0DB17D, 0x9CD24A93, 0x973346CC, 0x89022E7C);
		public static FolderPath Downloads => _Get(0x374DE290, 0x123F4565, 0x916439C4, 0x925E467B);
		public static FolderPath Favorites => _Get(0x1777F761, 0x68AD4D8A, 0x87BD30B7, 0x59FA33DD);
		public static FolderPath Fonts => _Get(0xFD228CB7, 0xAE114AE3, 0x864C16F3, 0x910AB8FE);
		public static FolderPath GameTasks => _Get(0x054FAE61, 0x4DD84787, 0x80B60902, 0x20C4B700);
		public static FolderPath History => _Get(0xD9DC8A3B, 0xB784432E, 0xA7815A11, 0x30A75963);
		public static FolderPath ImplicitAppShortcuts => _Get(0xBCB5256F, 0x79F64CEE, 0xB725DC34, 0xE402FD46);
		public static FolderPath InternetCache => _Get(0x352481E8, 0x33BE4251, 0xBA856007, 0xCAEDCF9D);
		public static FolderPath Libraries => _Get(0x1B3EA5DC, 0xB5874786, 0xB4EFBD1D, 0xC332AEAE);
		public static FolderPath Links => _Get(0xbfb9d5e0, 0xc6a9404c, 0xb2b2ae6d, 0xb6af4968);
		public static FolderPath LocalAppData => _Get(0xF1B32785, 0x6FBA4FCF, 0x9D557B8E, 0x7F157091);
		public static FolderPath LocalAppDataLow => _Get(0xA520A1A4, 0x17804FF6, 0xBD181673, 0x43C5AF16);
		public static FolderPath LocalizedResourcesDir => _Get(0x2A00375E, 0x224C49DE, 0xB8D1440D, 0xF7EF3DDC);
		public static FolderPath Music => _Get(0x4BD8D571, 0x6D1948D3, 0xBE974222, 0x20080E43);
		public static FolderPath MusicLibrary => _Get(0x2112AB0A, 0xC86A4FFE, 0xA3680DE9, 0x6E47012E);
		public static FolderPath NetHood => _Get(0xC5ABBF53, 0xE17F4121, 0x89008662, 0x6FC2C973);
		public static FolderPath OriginalImages => _Get(0x2C36C0AA, 0x58124b87, 0xBFD04CD0, 0xDFB19B39);
		public static FolderPath PhotoAlbums => _Get(0x69D2CF90, 0xFC334FB7, 0x9A0CEBB0, 0xF0FCB43C);
		public static FolderPath PicturesLibrary => _Get(0xA990AE9F, 0xA03B4E80, 0x94BC9912, 0xD7504104);
		public static FolderPath Pictures => _Get(0x33E28130, 0x4E1E4676, 0x835A9839, 0x5C3BC3BB);
		public static FolderPath Playlists => _Get(0xDE92C1C7, 0x837F4F69, 0xA3BB86E6, 0x31204A23);
		public static FolderPath PrintHood => _Get(0x9274BD8D, 0xCFD141C3, 0xB35EB13F, 0x55A758F4);
		public static FolderPath Profile => _Get(0x5E6C858F, 0x0E224760, 0x9AFEEA33, 0x17B67173);
		public static FolderPath ProgramData => _Get(0x62AB5D82, 0xFDC14DC3, 0xA9DD070D, 0x1D495D97);
		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFiles => new(__ProgramFiles ??= _ProgramFiles);
		static string __ProgramFiles;
		static FolderPath _ProgramFiles => _Get(0x905e63b6, 0xc1bf494e, 0xb29c65b7, 0x32d3d21a);
		//broken static FolderPath ProgramFilesX64 => _Get(0x6D809377, 0x6AF0444b, 0x8957A377, 0x3F02200E);
		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFilesX86 => new(__ProgramFilesX86 ??= _ProgramFilesX86);
		static string __ProgramFilesX86;
		static FolderPath _ProgramFilesX86 => _Get(0x7C5A40EF, 0xA0FB4BFC, 0x874AC0F2, 0xE0B9FA8E);
		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFilesCommon => _Get(0xF7F1ED05, 0x9F6D47A2, 0xAAAE29D3, 0x17C6F066);
		//broken static FolderPath ProgramFilesCommonX64 => _Get(0x6365D5A7, 0x0F0D45E5, 0x87F60DA5, 0x6B6A4F7D);
		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFilesCommonX86 => _Get(0xDE974D24, 0xD9C64D3E, 0xBF91F445, 0x5120B917);
		public static FolderPath Programs => _Get(0xA77F5D77, 0x2E2B44C3, 0xA6A2ABA6, 0x01054A51);
		public static FolderPath Public => _Get(0xDFDF76A2, 0xC82A4D63, 0x906A5644, 0xAC457385);
		public static FolderPath PublicDesktop => _Get(0xC4AA340D, 0xF20F4863, 0xAFEFF87E, 0xF2E6BA25);
		public static FolderPath PublicDocuments => _Get(0xED4824AF, 0xDCE445A8, 0x81E2FC79, 0x65083634);
		public static FolderPath PublicDownloads => _Get(0x3D644C9B, 0x1FB84f30, 0x9B45F670, 0x235F79C0);
		public static FolderPath PublicGameTasks => _Get(0xDEBF2536, 0xE1A84c59, 0xB6A24145, 0x86476AEA);
		public static FolderPath PublicLibraries => _Get(0x48DAF80B, 0xE6CF4F4E, 0xB8000E69, 0xD84EE384);
		public static FolderPath PublicMusic => _Get(0x3214FAB5, 0x97574298, 0xBB6192A9, 0xDEAA44FF);
		public static FolderPath PublicPictures => _Get(0xB6EBFB86, 0x6907413C, 0x9AF74FC2, 0xABF07CC5);
		public static FolderPath PublicRingtones => _Get(0xE555AB60, 0x153B4D17, 0x9F04A5FE, 0x99FC15EC);
		public static FolderPath PublicUserTiles_Win8 => _Get(0x0482af6c, 0x08f14c34, 0x8c90e17e, 0xc98b1e17);
		public static FolderPath PublicVideos => _Get(0x2400183A, 0x618549FB, 0xA2D84A39, 0x2A602BA3);
		public static FolderPath QuickLaunch => _Get(0x52a4f021, 0x7b7548a9, 0x9f6b4b87, 0xa210bc8f);
		public static FolderPath Recent => _Get(0xAE50C081, 0xEBD2438A, 0x86558A09, 0x2E34987A);
		public static FolderPath RecordedTV => _Get(0x1A6FDBA2, 0xF42D4358, 0xA798B74D, 0x745926C5);
		public static FolderPath ResourceDir => _Get(0x8AD10C31, 0x2ADB4296, 0xA8F7E470, 0x1232C972);
		public static FolderPath Ringtones => _Get(0xC870044B, 0xF49E4126, 0xA9C3B52A, 0x1FF411E8);
		public static FolderPath RoamingAppData => _Get(0x3EB685DB, 0x65F94CF6, 0xA03AE3EF, 0x65729F3D);
		public static FolderPath RoamedTileImages_Win8 => _Get(0xAAA8D5A5, 0xF1D64259, 0xBAA878E7, 0xEF60835E);
		public static FolderPath RoamingTiles_Win8 => _Get(0x00BCFC5A, 0xED944e48, 0x96A13F62, 0x17F21990);
		public static FolderPath SampleMusic => _Get(0xB250C668, 0xF57D4EE1, 0xA63C290E, 0xE7D1AA1F);
		public static FolderPath SamplePictures => _Get(0xC4900540, 0x23794C75, 0x844B64E6, 0xFAF8716B);
		public static FolderPath SamplePlaylists => _Get(0x15CA69B3, 0x30EE49C1, 0xACE16B5E, 0xC372AFB5);
		public static FolderPath SampleVideos => _Get(0x859EAD94, 0x2E8548AD, 0xA71A0969, 0xCB56A6CD);
		public static FolderPath SavedGames => _Get(0x4C5C32FF, 0xBB9D43b0, 0xB5B42D72, 0xE54EAAA4);
		public static FolderPath SavedPictures => _Get(0x3B193882, 0xD3AD4eab, 0x965A6982, 0x9D1FB59F);
		public static FolderPath SavedPicturesLibrary => _Get(0xE25B5812, 0xBE884bd9, 0x94B02923, 0x3477B6C3);
		public static FolderPath SavedSearches => _Get(0x7d1d3a04, 0xdebb4115, 0x95cf2f29, 0xda2920da);
		public static FolderPath Screenshots_Win8 => _Get(0xb7bede81, 0xdf944682, 0xa7d857a5, 0x2620b86f);
		public static FolderPath SearchHistory_Win81 => _Get(0x0D4C3DB6, 0x03A3462F, 0xA0E60892, 0x4C41B5D4);
		public static FolderPath SearchTemplates_Win81 => _Get(0x7E636BFE, 0xDFA94D5E, 0xB456D7B3, 0x9851D8A9);
		public static FolderPath SendTo => _Get(0x8983036C, 0x27C0404B, 0x8F08102D, 0x10DCFD74);
		public static FolderPath SidebarDefaultParts => _Get(0x7B396E54, 0x9EC54300, 0xBE0A2482, 0xEBAE1A26);
		public static FolderPath SidebarParts => _Get(0xA75D362E, 0x50FC4fb7, 0xAC2CA8BE, 0xAA314493);
		public static FolderPath SkyDrive_Win81 => _Get(0xA52BBA46, 0xE9E1435f, 0xB3D928DA, 0xA648C0F6);
		public static FolderPath SkyDriveCameraRoll_Win81 => _Get(0x767E6811, 0x49CB4273, 0x87C220F3, 0x55E1085B);
		public static FolderPath SkyDriveDocuments_Win81 => _Get(0x24D89E24, 0x2F194534, 0x9DDE6A66, 0x71FBB8FE);
		public static FolderPath SkyDrivePictures_Win81 => _Get(0x339719B5, 0x8C474894, 0x94C2D8F7, 0x7ADD44A6);
		public static FolderPath StartMenu => _Get(0x625B53C3, 0xAB484EC1, 0xBA1FA1EF, 0x4146FC19);
		public static FolderPath Startup => _Get(0xB97D20BB, 0xF46A4C97, 0xBA105E36, 0x08430854);
		/// <summary>More info in class help.</summary>
		public static FolderPath System => new(__System ??= _System);
		static string __System;
		static FolderPath _System => _Get(0x1AC14E77, 0x02E74E5D, 0xB7442EB1, 0xAE5198B7);
		/// <summary>More info in class help.</summary>
		public static FolderPath SystemX86 => _Get(0xD65231B0, 0xB2F14857, 0xA4CEA8E7, 0xC6EA7D27);
		public static FolderPath Templates => _Get(0xA63293E8, 0x664E48DB, 0xA079DF75, 0x9E0509F7);
		public static FolderPath TreeProperties => _Get(0x9E3995AB, 0x1F9C4F13, 0xB82748B2, 0x4B6C7174);
		public static FolderPath UserProfiles => _Get(0x0762D272, 0xC50A4BB0, 0xA382697D, 0xCD729B80);
		public static FolderPath UserProgramFiles => _Get(0x5CD7AEE2, 0x22194A67, 0xB85D6C9C, 0xE15660CB);
		public static FolderPath UserProgramFilesCommon => _Get(0xBCBD3057, 0xCA5C4622, 0xB42DBC56, 0xDB0AE516);
		public static FolderPath Videos => _Get(0x18989B1D, 0x99B5455B, 0x841CAB7C, 0x74E4DDFC);
		public static FolderPath VideosLibrary => _Get(0x491E922F, 0x56434AF4, 0xA7EB4E7A, 0x138D8174);
		public static FolderPath Windows => new(__Windows ??= _Windows);
		static string __Windows;
		static FolderPath _Windows => _Get(0xF38BF404, 0x1D4342F2, 0x930567DE, 0x0B28FC23);
		
		/// <summary>
		/// Gets <ms>ITEMIDLIST</ms> of known/special virtual folders (eg Control Panel), as string like <c>":: 12345678..."</c> or as <see cref="Pidl"/>.
		/// </summary>
		public static class shell {
			public static FolderPath AddNewPrograms => _GetV(0xde61d971, 0x5ebc4f02, 0xa3a96c82, 0x895e5c04);
			public static FolderPath Apps_Win8 => _GetV(0x1e87508d, 0x89c242f0, 0x8a7e645a, 0x0f50ca58);
			public static FolderPath AppUpdates => _GetV(0xa305ce99, 0xf527492b, 0x8b1a7e76, 0xfa98d6e4);
			public static FolderPath ChangeRemovePrograms => _GetV(0xdf7266ac, 0x92744867, 0x8d553bd6, 0x61de872d);
			public static FolderPath Computer => _GetV(0x0AC0837C, 0xBBF8452A, 0x850D79D0, 0x8E667CA7);
			public static FolderPath Conflict => _GetV(0x4bfefb45, 0x347d4006, 0xa5beac0c, 0xb0567192);
			public static FolderPath Connections => _GetV(0x6F0CD92B, 0x2E9745D1, 0x88FFB0D1, 0x86B8DEDD);
			public static FolderPath ControlPanel => _GetV(0x82A74AEB, 0xAEB4465C, 0xA014D097, 0xEE346D63);
			public static FolderPath Games => _GetV(0xCAC52C1A, 0xB53D4edc, 0x92D76B2E, 0x8AC19434);
			public static FolderPath HomeGroup => _GetV(0x52528A6B, 0xB9E34ADD, 0xB60D588C, 0x2DBA842D);
			public static FolderPath HomeGroupCurrentUser_Win8 => _GetV(0x9B74B6A3, 0x0DFD4f11, 0x9E785F78, 0x00F2E772);
			public static FolderPath Internet => _GetV(0x4D9F7874, 0x4E0C4904, 0x967B40B0, 0xD20C3E4B);
			public static FolderPath Network => _GetV(0xD20BEEC4, 0x5CA84905, 0xAE3BBF25, 0x1EA09B53);
			public static FolderPath Printers => _GetV(0x76FC4E2D, 0xD6AD4519, 0xA66337BD, 0x56068185);
			public static FolderPath RecycleBin => _GetV(0xB7534046, 0x3ECB4C18, 0xBE4E64CD, 0x4CB7D6AC);
			public static FolderPath SEARCH_CSC => _GetV(0xee32e446, 0x31ca4aba, 0x814fa5eb, 0xd2fd6d5e);
			public static FolderPath SearchHome => _GetV(0x190337d1, 0xb8ca4121, 0xa6396d47, 0x2d16972a);
			public static FolderPath SEARCH_MAPI => _GetV(0x98ec0e18, 0x20984d44, 0x86446697, 0x9315a281);
			public static FolderPath SyncManager => _GetV(0x43668BF8, 0xC14E49B2, 0x97C97477, 0x84D784B7);
			public static FolderPath SyncResults => _GetV(0x289a9a43, 0xbe444057, 0xa41b587a, 0x76d7e7f9);
			public static FolderPath SyncSetup => _GetV(0x0F214138, 0xB1D34a90, 0xBBA927CB, 0xC0C5389A);
			public static FolderPath UsersFiles => _GetV(0xf3ce0f7c, 0x49014acc, 0x8648d5d4, 0x4b04ef8f);
			public static FolderPath UsersLibraries => _GetV(0xA302545D, 0xDEFF464b, 0xABE861C8, 0x648D939B);
			
			public static Pidl pidlAddNewPrograms => _GetVI(0xde61d971, 0x5ebc4f02, 0xa3a96c82, 0x895e5c04);
			public static Pidl pidlApps_Win8 => _GetVI(0x1e87508d, 0x89c242f0, 0x8a7e645a, 0x0f50ca58);
			public static Pidl pidlAppUpdates => _GetVI(0xa305ce99, 0xf527492b, 0x8b1a7e76, 0xfa98d6e4);
			public static Pidl pidlChangeRemovePrograms => _GetVI(0xdf7266ac, 0x92744867, 0x8d553bd6, 0x61de872d);
			public static Pidl pidlComputer => _GetVI(0x0AC0837C, 0xBBF8452A, 0x850D79D0, 0x8E667CA7);
			public static Pidl pidlConflict => _GetVI(0x4bfefb45, 0x347d4006, 0xa5beac0c, 0xb0567192);
			public static Pidl pidlConnections => _GetVI(0x6F0CD92B, 0x2E9745D1, 0x88FFB0D1, 0x86B8DEDD);
			public static Pidl pidlControlPanel => _GetVI(0x82A74AEB, 0xAEB4465C, 0xA014D097, 0xEE346D63);
			public static Pidl pidlGames => _GetVI(0xCAC52C1A, 0xB53D4edc, 0x92D76B2E, 0x8AC19434);
			public static Pidl pidlHomeGroup => _GetVI(0x52528A6B, 0xB9E34ADD, 0xB60D588C, 0x2DBA842D);
			public static Pidl pidlHomeGroupCurrentUser_Win8 => _GetVI(0x9B74B6A3, 0x0DFD4f11, 0x9E785F78, 0x00F2E772);
			public static Pidl pidlInternet => _GetVI(0x4D9F7874, 0x4E0C4904, 0x967B40B0, 0xD20C3E4B);
			public static Pidl pidlNetwork => _GetVI(0xD20BEEC4, 0x5CA84905, 0xAE3BBF25, 0x1EA09B53);
			public static Pidl pidlPrinters => _GetVI(0x76FC4E2D, 0xD6AD4519, 0xA66337BD, 0x56068185);
			public static Pidl pidlRecycleBin => _GetVI(0xB7534046, 0x3ECB4C18, 0xBE4E64CD, 0x4CB7D6AC);
			public static Pidl pidlSEARCH_CSC => _GetVI(0xee32e446, 0x31ca4aba, 0x814fa5eb, 0xd2fd6d5e);
			public static Pidl pidlSearchHome => _GetVI(0x190337d1, 0xb8ca4121, 0xa6396d47, 0x2d16972a);
			public static Pidl pidlSEARCH_MAPI => _GetVI(0x98ec0e18, 0x20984d44, 0x86446697, 0x9315a281);
			public static Pidl pidlSyncManager => _GetVI(0x43668BF8, 0xC14E49B2, 0x97C97477, 0x84D784B7);
			public static Pidl pidlSyncResults => _GetVI(0x289a9a43, 0xbe444057, 0xa41b587a, 0x76d7e7f9);
			public static Pidl pidlSyncSetup => _GetVI(0x0F214138, 0xB1D34a90, 0xBBA927CB, 0xC0C5389A);
			public static Pidl pidlUsersFiles => _GetVI(0xf3ce0f7c, 0x49014acc, 0x8648d5d4, 0x4b04ef8f);
			public static Pidl pidlUsersLibraries => _GetVI(0xA302545D, 0xDEFF464b, 0xABE861C8, 0x648D939B);
		}
		
		#endregion
		
		#region other paths
		
		/// <summary>
		/// Temp folder (temporary files) of this user account.
		/// </summary>
		public static FolderPath Temp => new(__temp ??= Path.GetTempPath().TrimEnd('\\'));
		static string __temp;
		
		/// <summary>
		/// Folder containing assemblies of this app.
		/// </summary>
		/// <remarks>
		/// Uses <see cref="AppContext.BaseDirectory"/>.
		/// </remarks>
		/// <seealso cref="process.thisExePath"/>
		public static FolderPath ThisApp => new(__thisApp ??= ThisAppBS.TrimEnd('\\'));
		static string __thisApp;
		
		/// <summary>
		/// <see cref="ThisApp"/> with appended backslash character.
		/// </summary>
		/// <remarks>
		/// Uses <see cref="AppContext.BaseDirectory"/>.
		/// </remarks>
		public static string ThisAppBS => __thisAppBS ??= AppContext.BaseDirectory; //info: AppDomain.CurrentDomain.BaseDirectory calls it
		static string __thisAppBS;
		//Can change: AppDomain.CurrentDomain.SetData("APP_CONTEXT_BASE_DIRECTORY", "C:\\");
		
		#region set auto/once
		
		/// <summary>
		/// Don't auto-create folders when accessing <see cref="ThisAppDocuments"/>, <see cref="ThisAppTemp"/>, <see cref="ThisAppDataLocal"/> or <see cref="ThisAppDataRoaming"/> in this thread.
		/// </summary>
		/// <remarks>
		/// Normally this is used temporarily, then restored (set = <c>false</c>).
		/// </remarks>
		public static bool noAutoCreate {
			get => _noAutoCreate;
			set { _noAutoCreate = value; }
		}
		[ThreadStatic] static bool _noAutoCreate;
		
		static readonly object _lock = new();
		
		static string _SetAuto(ref string propVar, string value, bool create) {
			lock (_lock) {
				if (propVar == null) {
					if (create && !_noAutoCreate) filesystem.createDirectory(value);
					propVar = value;
				}
			}
			return propVar;
		}
		
		static void _SetOnce(ref string propVar, string value, bool create, [CallerMemberName] string m_ = null) {
			lock (_lock) {
				if (propVar != null) {
#if DEBUG
					if (!Debugger.IsAttached) //debugger may get the property. Then _SetAuto sets default value.
#endif
						throw new InvalidOperationException("folders." + m_ + " is already set.");
				}
				if (create && !_noAutoCreate) filesystem.createDirectory(value);
				propVar = value;
			}
		}
		
		static string _DefThisApp(string baseDir, string portableSubdir, bool warning = false) {
			bool ee = script.role == SRole.EditorExtension;
			
			if (ScriptEditor.IsPortable) return PortableData_ + "\\" + portableSubdir + (ee ? null : @"\_script");
			
			return baseDir + (ee ? @"\LibreAutomate" : @"\LibreAutomate\_script");
		}
		
		internal static string PortableData_ => __portableData ??= GetPortableDataDir_(Editor.Path);
		static string __portableData;
		
		static internal string GetPortableDataDir_(string appPath) {
			var s = appPath + @"\data";
			//if (filesystem.exists(s, true).File) return pathname.normalize(filesystem.loadText(s), appPath);
			return s;
		}
		
		#endregion
		
		/// <summary>
		/// Gets or sets path of folder "temporary files of this application".
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown by the <c>set</c> function if this property is already set.</exception>
		/// <remarks>
		/// Default path depends on script role (<see cref="script.role"/> and portable mode (<see cref="ScriptEditor.IsPortable"/>):
		/// - <c>miniProgram</c> and <c>exeProgram</c> - <c>folders.Temp + @"LibreAutomate\_script"</c>. Or <c>folders.Temp + "Au"</c>, if exists (for backward compatibility).
		/// - <c>editorExtension</c> - <c>folders.Temp + "LibreAutomate"</c>. Cannot be changed.
		/// - Portable <c>miniProgram</c> and <c>exeProgram</c> - <c>folders.ThisApp + @"data\temp\_script"</c>. Note: <c>exeProgram</c> launched not from editor isn't portable.
		/// - Portable <c>editorExtension</c> - <c>folders.ThisApp + @"data\temp"</c>. Cannot be changed.
		/// 
		/// The <c>set</c> function does not change system settings. It just remembers a string that will be later returned by the <c>get</c> function in this process.
		/// Creates the folder if does not exist when <c>set</c> or <c>get</c> function called first time in this process, unless <see cref="noAutoCreate"/> <c>true</c>.
		/// </remarks>
		public static FolderPath ThisAppTemp {
			get => new(__thisAppTemp ?? _SetAuto(ref __thisAppTemp, _DefThisApp(Temp, "temp"), create: true));
			set => _SetOnce(ref __thisAppTemp, value, create: true);
		}
		static string __thisAppTemp;
		
		/// <summary>
		/// Gets or sets path of folder "user document files of this application".
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown by the <c>set</c> function if this property is already set.</exception>
		/// <remarks>
		/// Default path depends on script role (<see cref="script.role"/>) and portable mode (<see cref="ScriptEditor.IsPortable"/>):
		/// - <c>miniProgram</c> and <c>exeProgram</c> - <c>folders.Documents + @"LibreAutomate\_script"</c>. Or <c>folders.Documents + "Au"</c>, if exists (for backward compatibility).
		/// - <c>editorExtension</c> - <c>folders.Documents + "LibreAutomate"</c>. Cannot be changed.
		/// - Portable <c>miniProgram</c> and <c>exeProgram</c> - <c>folders.ThisApp + @"data\doc\_script"</c>. Note: <c>exeProgram</c> launched not from editor isn't portable.
		/// - Portable <c>editorExtension</c> - <c>folders.ThisApp + @"data\doc"</c>. Cannot be changed.
		/// 
		/// The <c>set</c> function does not change system settings. It just remembers a string that will be later returned by the <c>get</c> function in this process.
		/// Creates the folder if does not exist when <c>set</c> or <c>get</c> function called first time in this process, unless <see cref="noAutoCreate"/> <c>true</c>.
		/// </remarks>
		public static FolderPath ThisAppDocuments {
			get => new(__thisAppDocuments ?? _SetAuto(ref __thisAppDocuments, _DefThisApp(Documents, "doc", warning: true), create: true));
			set => _SetOnce(ref __thisAppDocuments, value, create: true);
		}
		static string __thisAppDocuments;
		
		/// <summary>
		/// Gets or sets path of folder "local (non-roaming) private files of this application of this user account".
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown by the <c>set</c> function if this property is already set.</exception>
		/// <remarks>
		/// Default path depends on script role (<see cref="script.role"/> and portable mode (<see cref="ScriptEditor.IsPortable"/>):
		/// - <c>miniProgram</c> and <c>exeProgram</c> - <c>folders.LocalAppData + @"LibreAutomate\_script"</c>. Or <c>folders.LocalAppData + "Au"</c>, if exists (for backward compatibility).
		/// - <c>editorExtension</c> - <c>folders.LocalAppData + "LibreAutomate"</c>. Cannot be changed.
		/// - Portable <c>miniProgram</c> and <c>exeProgram</c> - <c>folders.ThisApp + @"data\appLocal\_script"</c>. Note: <c>exeProgram</c> launched not from editor isn't portable.
		/// - Portable <c>editorExtension</c> - <c>folders.ThisApp + @"data\appLocal"</c>. Cannot be changed.
		/// 
		/// The <c>set</c> function does not change system settings. It just remembers a string that will be later returned by the <c>get</c> function in this process.
		/// Creates the folder if does not exist when <c>set</c> or <c>get</c> function called first time in this process, unless <see cref="noAutoCreate"/> <c>true</c>.
		/// </remarks>
		public static FolderPath ThisAppDataLocal {
			get => new(__thisAppDataLocal ?? _SetAuto(ref __thisAppDataLocal, _DefThisApp(LocalAppData, "appLocal", warning: true), create: true));
			set => _SetOnce(ref __thisAppDataLocal, value, create: true);
		}
		static string __thisAppDataLocal;
		
		/// <summary>
		/// Gets or sets path of folder "roaming private files of this application of this user account".
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown by the <c>set</c> function if this property is already set.</exception>
		/// <remarks>
		/// Default path depends on script role (<see cref="script.role"/> and portable mode (<see cref="ScriptEditor.IsPortable"/>):
		/// - <c>miniProgram</c> and <c>exeProgram</c> - <c>folders.RoamingAppData + @"LibreAutomate\_script"</c>. Or <c>folders.RoamingAppData + "Au"</c>, if exists (for backward compatibility).
		/// - <c>editorExtension</c> - <c>folders.RoamingAppData + "LibreAutomate"</c>. Cannot be changed.
		/// - Portable <c>miniProgram</c> and <c>exeProgram</c> - <c>folders.ThisApp + @"data\appRoaming\_script"</c>. Note: <c>exeProgram</c> launched not from editor isn't portable.
		/// - Portable <c>editorExtension</c> - <c>folders.ThisApp + @"data\appRoaming"</c>. Cannot be changed.
		/// 
		/// The <c>set</c> function does not change system settings. It just remembers a string that will be later returned by the <c>get</c> function in this process.
		/// Creates the folder if does not exist when <c>set</c> or <c>get</c> function called first time in this process, unless <see cref="noAutoCreate"/> <c>true</c>.
		/// </remarks>
		public static FolderPath ThisAppDataRoaming {
			get => new(__thisAppDataRoaming ?? _SetAuto(ref __thisAppDataRoaming, _DefThisApp(RoamingAppData, "appRoaming"), create: true));
			set => _SetOnce(ref __thisAppDataRoaming, value, create: true);
		}
		static string __thisAppDataRoaming;
		
		[EditorBrowsable(EditorBrowsableState.Never)] //renamed
		public static FolderPath ThisAppData {
			get => ThisAppDataRoaming;
			set => ThisAppDataRoaming = value;
		} //info: unexpandPath ignores ThisAppX.
		
		/// <summary>
		/// Gets or sets path of folder "common (all users) private files of this application".
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown by the <c>set</c> function if this property is already set.</exception>
		/// <remarks>
		/// Default path depends on script role (<see cref="script.role"/> and portable mode (<see cref="ScriptEditor.IsPortable"/>):
		/// - <c>miniProgram</c> and <c>exeProgram</c> - <c>folders.ProgramData + @"LibreAutomate\_script"</c>. Or <c>folders.ProgramData + "Au"</c>, if exists (for backward compatibility).
		/// - <c>editorExtension</c> - <c>folders.ProgramData + "LibreAutomate"</c>. Cannot be changed.
		/// - Portable <c>miniProgram</c> and <c>exeProgram</c> - <c>folders.ThisApp + @"data\appCommon\_script"</c>. Note: <c>exeProgram</c> launched not from editor isn't portable.
		/// - Portable <c>editorExtension</c> - <c>folders.ThisApp + @"data\appCommon"</c>. Cannot be changed.
		/// 
		/// The <c>set</c> function does not change system settings. It just remembers a string that will be later returned by the <c>get</c> function in this process.
		/// This function does not auto-create the folder; usually it is created when installing the application; the script editor does not use and does not install it.
		/// Note: the <c>ProgramData</c> folder has special security permissions. Programs running not as administrator usually cannot write there, unless your installer changed folder security permissions.
		/// </remarks>
		public static FolderPath ThisAppDataCommon {
			get => new(__thisAppDataCommon ?? _SetAuto(ref __thisAppDataCommon, _DefThisApp(ProgramData, "appCommon"), create: false));
			set => _SetOnce(ref __thisAppDataCommon, value, create: false);
		}
		static string __thisAppDataCommon;
		
		/// <summary>
		/// Gets or sets path of folder "images of this application".
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown by the <c>set</c> function if this property is already set.</exception>
		/// <remarks>
		/// Default is <c>ThisAppBS + "Images"</c>.
		/// 
		/// Used by functions of these classes: <see cref="icon"/>, <see cref="popupMenu"/>, <see cref="toolbar"/>, <see cref="uiimage"/>, possibly some other.
		/// This function does not auto-create the folder; usually it is created when installing the application; the script editor does not use and does not install it.
		/// </remarks>
		public static FolderPath ThisAppImages {
			get => new(__thisAppImages ?? _SetAuto(ref __thisAppImages, ThisAppBS + "Images", create: false));
			set => _SetOnce(ref __thisAppImages, value, create: false);
		}
		static string __thisAppImages;
		
		/// <summary>
		/// Gets the root directory of this application, like <c>@"C:\"</c> or <c>@"\\server\share\"</c>.
		/// </summary>
		/// <remarks>
		/// See <see cref="Path.GetPathRoot"/>.
		/// </remarks>
		public static string ThisAppDriveBS => __thisAppDrive ??= pathname.GetRootBS_(ThisAppBS);
		static string __thisAppDrive;
		//public static FolderPath ThisAppDrive => new(__thisAppDrive ??= Path.GetPathRoot(ThisAppBS));
		
		/// <summary>
		/// Gets folder of the script editor.
		/// Available in the script editor process and in scripts launched from it. Elsewhere <c>null</c>.
		/// </summary>
		public static FolderPath Editor { get; internal set; }
		
		/// <summary>
		/// Gets folder of current workspace.
		/// Available in the script editor process and in scripts launched from it. Elsewhere <c>null</c>.
		/// </summary>
		public static FolderPath Workspace {
			get => __workspace;
			internal set { __workspace = value; WorkspaceDriveBS = pathname.GetRootBS_(value); }
		}
		static FolderPath __workspace;
		
		/// <summary>
		/// Gets the root directory of <see cref="Workspace"/>, like <c>@"C:\"</c> or <c>@"\\server\share\"</c>.
		/// </summary>
		/// <remarks>
		/// See <see cref="Path.GetPathRoot"/>.
		/// </remarks>
		public static string WorkspaceDriveBS { get; private set; }
		
		//CONSIDER:
		//public static FolderPath ThisLibrarySettings { get => field ??= ThisAppDataRoaming; set; }
		
#if !DEBUG //fbc
		/// <summary>
		/// Gets drive type (fixed, removable, network, etc) of <see cref="ThisAppDriveBS"/>.
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)] //more annoying than useful. Intellisense selects it when the user types "thisApp". And maybe this class isn't the best place for it. Probably users will not look for such function here or somewhere in this library; they'll use DriveInfo. In any case, this is not very useful because: 1. Detects external SSD as Fixed; 2. The removable drive (SSD or not) may be used either as portable or always with the same computer.
		public static DriveType thisAppDriveType => __driveTypeApp ??= __GetDriveType(ThisAppDriveBS);
		static DriveType? __driveTypeApp;
		
		/// <summary>
		/// Gets drive type (fixed, removable, network, etc) of <see cref="WorkspaceDriveBS"/>.
		/// </summary>
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static DriveType workspaceDriveType => __GetDriveType(WorkspaceDriveBS);
		
		//note: don't use this func with any paths. It is for the above 2 funcs only.
		static DriveType __GetDriveType(string path) {
			path = pathname.unprefixLongPath(path);
			if (path.Starts(@"\\")) return DriveType.Network; //GetDriveType does not support it. DriveInfo throws exception.
			return (DriveType)Api.GetDriveType(path);
		}
#endif
		
		/// <summary>
		/// Gets folder path of the caller source code file.
		/// </summary>
		/// <param name="f_">[](xref:caller_info)</param>
		/// <seealso cref="CallerFilePathAttribute"/>
		/// <seealso cref="script.sourcePath(string)"/>
		public static FolderPath sourceCode([CallerFilePath] string f_ = null) => new(pathname.getDirectory(f_));
		
		/// <summary>
		/// Gets folder path of the main source code file of this program or of a library.
		/// </summary>
		/// <param name="asm">An assembly compiled by LibreAutomate. If <c>null</c>, uses <see cref="Assembly.GetEntryAssembly"/>.</param>
		/// <seealso cref="script.sourcePath(bool, Assembly)"/>
		public static FolderPath sourceCodeMain(Assembly asm = null) => new(pathname.getDirectory(script.sourcePath(false, asm)));
		
		/// <summary>
		/// Gets non-redirected path of the System32 folder.
		/// </summary>
		/// <remarks>
		/// If this process is 32-bit and OS is 64-bit, when it uses the <see cref="System"/> folder path (<c>@"C:\WINDOWS\system32"</c>), the OS in most cases redirects it to <c>@"C:\Windows\SysWOW64"</c>, which contains 32-bit versions of program files. Use SystemX64 when you want to avoid the redirection and access the true System32 folder which on 64-bit OS contains 64-bit program files.
		/// More info in class help.
		/// </remarks>
		/// <seealso cref="FileSystemRedirection"/>
		/// <seealso cref="osVersion.is32BitProcessAnd64BitOS"/>
		public static FolderPath SystemX64 => new(__SystemX64 ??= osVersion.is32BitProcessAnd64BitOS ? Windows + "Sysnative" : System);
		static string __SystemX64;
		
		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFilesX64 => new(__ProgramFilesX64 ??= osVersion.is32BitProcessAnd64BitOS ? envVar("ProgramW6432") : ProgramFiles);
		static string __ProgramFilesX64;
		
		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFilesCommonX64 => new(__ProgramFilesCommonX64 ??= osVersion.is32BitProcessAnd64BitOS ? envVar("CommonProgramW6432") : ProgramFilesCommon);
		static string __ProgramFilesCommonX64;
		//The normal retrieving method for these folders is broken. Fails even on 64-bit OS if process is 32-bit.
		
		/// <summary>
		/// Gets .NET runtime folder, like <c>C:\Program Files\dotnet\shared\Microsoft.NETCore.App\8.0.6</c>.
		/// </summary>
		public static FolderPath NetRuntime => new(__netRuntime ??= NetRuntimeBS.TrimEnd('\\'));
		static string __netRuntime;
		
		/// <summary>
		/// Gets .NET runtime folder with <c>'\\'</c> at the end, like <c>C:\Program Files\dotnet\shared\Microsoft.NETCore.App\8.0.6\</c>.
		/// </summary>
		public static string NetRuntimeBS => __netRuntimeBS ??= RuntimeEnvironment.GetRuntimeDirectory();
		static string __netRuntimeBS;
		
		/// <summary>
		/// Gets .NET runtime desktop folder, like <c>C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App\8.0.6</c>.
		/// </summary>
		public static FolderPath NetRuntimeDesktop => new(__netRuntimeDesktop ??= NetRuntimeDesktopBS.TrimEnd('\\'));
		static string __netRuntimeDesktop;
		
		/// <summary>
		/// Gets .NET runtime desktop folder with <c>'\\'</c> at the end, like <c>C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App\8.0.6\</c>.
		/// </summary>
		public static string NetRuntimeDesktopBS => __netRuntimeDesktopBS ??= _NetRuntimeDesktopBS();
		static string __netRuntimeDesktopBS;
		
		static string _NetRuntimeDesktopBS() {
			var s = typeof(Accessibility.IAccessible).Assembly.Location;
			if (s.NE()) return NetRuntimeBS; //single-file app
			s = pathname.getDirectory(s, withSeparator: true);
			Debug.Assert(s != NetRuntimeBS || s.Starts(ThisAppBS));
			return s;
			//note: cannot get NetRuntimeDesktopBS from NetRuntimeBS.
			//	Can be different version, eg Microsoft.NETCore.App\8.0.0-rc.1.23419.4 and Microsoft.WindowsDesktop.App\8.0.0-rc.1.23420.5.
		}
		
		/// <summary>
		/// Gets CD/DVD drive path, like <c>@"D:\"</c>.
		/// </summary>
		/// <returns><c>null</c> if unavailable.</returns>
		public static FolderPath CdDvdDrive {
			get {
				foreach (var di in DriveInfo.GetDrives()) {
					if (di.DriveType == DriveType.CDRom) return new(di.Name);
				}
				return default;
			}
		}
		
		/// <summary>Calls <see cref="removableDrive(int)"/>(0).</summary>
		public static FolderPath RemovableDrive0 => removableDrive(0);
		/// <summary>Calls <see cref="removableDrive(int)"/>(1).</summary>
		public static FolderPath RemovableDrive1 => removableDrive(1);
		/// <summary>Calls <see cref="removableDrive(int)"/>(2).</summary>
		public static FolderPath RemovableDrive2 => removableDrive(2);
		/// <summary>Calls <see cref="removableDrive(int)"/>(3).</summary>
		public static FolderPath RemovableDrive3 => removableDrive(3);
		
		/// <summary>
		/// Gets removable/external/USB drive path, like <c>@"F:\"</c>.
		/// </summary>
		/// <returns><c>null</c> if unavailable.</returns>
		/// <param name="driveIndex">0-based removable drive index.</param>
		/// <remarks>
		/// Calls <see cref="DriveInfo.GetDrives"/> and counts drives of type <see cref="DriveType.Removable"/>.
		/// </remarks>
		public static FolderPath removableDrive(int driveIndex = 0) {
			foreach (DriveInfo di in DriveInfo.GetDrives()) {
				if (di.DriveType == DriveType.Removable && driveIndex-- == 0) return new(di.Name);
			}
			return default;
		}
		
		/// <summary>
		/// Gets removable/external/USB drive name (like <c>@"F:\"</c>) by its volume label.
		/// </summary>
		/// <returns><c>null</c> if unavailable.</returns>
		/// <param name="volumeLabel">Volume label. You can see it in drive <b>Properties</b> dialog; it is not the drive name that is displayed in File Explorer.</param>
		public static FolderPath removableDrive(string volumeLabel) {
			foreach (DriveInfo di in DriveInfo.GetDrives()) {
				if (di.DriveType == DriveType.Removable) {
					string v = null; try { v = di.VolumeLabel; } catch { continue; }
					if (!v.Eqi(volumeLabel)) continue;
					return new(di.Name);
				}
			}
			return default;
		}
		
		/// <summary>
		/// Gets the value of an environment variable in current process.
		/// </summary>
		/// <returns><c>null</c> if variable not found.</returns>
		/// <seealso cref="Environment.GetEnvironmentVariable"/>
		/// <seealso cref="Environment.SetEnvironmentVariable"/>
		/// <seealso cref="pathname.expand"/>
		public static FolderPath envVar(string envVar) => new(Api.GetEnvironmentVariable(envVar));
		
		#endregion
		
		#region private functions
		
		//Gets non-virtual known folder path from KNOWNFOLDERID specified with 4 uints.
		static FolderPath _Get(uint a, uint b, uint c, uint d) {
			//info: we don't use caching. It seems the API use caching internally.
			//tested: with IKnownFolder much slower.
			
			var guid = new _Api.KNOWNFOLDERID(a, b, c, d);
			if (0 != _Api.SHGetKnownFolderPath(guid, _Api.KNOWN_FOLDER_FLAG.KF_FLAG_DONT_VERIFY, default, out string R)) R = null;
			return new(R);
		}
		
		//Gets virtual known folder ITEMIDLIST from KNOWNFOLDERID specified with 4 uints.
		static Pidl _GetVI(uint a, uint b, uint c, uint d) {
			var guid = new _Api.KNOWNFOLDERID(a, b, c, d);
			if (0 != _Api.SHGetKnownFolderIDList(guid, _Api.KNOWN_FOLDER_FLAG.KF_FLAG_DONT_VERIFY, default, out IntPtr pidl)) return null;
			return new Pidl(pidl);
		}
		
		//Gets virtual known folder ITEMIDLIST from KNOWNFOLDERID specified with 4 uints.
		//Returns string ":: ITEMIDLIST".
		static FolderPath _GetV(uint a, uint b, uint c, uint d) {
			using var pidl = _GetVI(a, b, c, d); //never mind: could do it without creating new Pidl
			return new(pidl?.ToHexString());
		}
		
		#endregion
		
		#region API
		
		static class _Api {
			//GUID that can be inited with 4 uints.
			internal struct KNOWNFOLDERID {
				uint _a; ushort _b, _c; byte _d, _e, _f, _g, _h, _i, _j, _k;
				
				public KNOWNFOLDERID(uint a, uint b, uint c, uint d) {
					_a = a;
					_b = (ushort)(b >> 16);
					_c = (ushort)b;
					_d = (byte)(c >> 24);
					_e = (byte)(c >> 16);
					_f = (byte)(c >> 8);
					_g = (byte)c;
					_h = (byte)(d >> 24);
					_i = (byte)(d >> 16);
					_j = (byte)(d >> 8);
					_k = (byte)d;
				}
			}
			
			[DllImport("shell32.dll")]
			internal static extern int SHGetKnownFolderPath(in KNOWNFOLDERID rfid, KNOWN_FOLDER_FLAG dwFlags, IntPtr hToken, out string ppszPath);
			
			[DllImport("shell32.dll")]
			internal static extern int SHGetKnownFolderIDList(in KNOWNFOLDERID rfid, KNOWN_FOLDER_FLAG dwFlags, IntPtr hToken, out IntPtr ppidl);
			
			[Flags]
			internal enum KNOWN_FOLDER_FLAG : uint {
				KF_FLAG_SIMPLE_IDLIST = 0x00000100,
				KF_FLAG_NOT_PARENT_RELATIVE = 0x00000200,
				KF_FLAG_DEFAULT_PATH = 0x00000400,
				KF_FLAG_INIT = 0x00000800,
				KF_FLAG_NO_ALIAS = 0x00001000,
				KF_FLAG_DONT_UNEXPAND = 0x00002000,
				KF_FLAG_DONT_VERIFY = 0x00004000,
				KF_FLAG_CREATE = 0x00008000,
				KF_FLAG_NO_APPCONTAINER_REDIRECTION = 0x00010000,
				KF_FLAG_ALIAS_ONLY = 0x80000000
			}
			
			internal enum KF_DEFINITION_FLAGS {
				KFDF_LOCAL_REDIRECT_ONLY = 0x2,
				KFDF_ROAMABLE = 0x4,
				KFDF_PRECREATE = 0x8,
				KFDF_STREAM = 0x10,
				KFDF_PUBLISHEXPANDEDPATH = 0x20
			}
			
#pragma warning disable CS0649 //field never assigned
			internal struct KNOWNFOLDER_DEFINITION {
				public KF_CATEGORY category;
				public string pszName;
				public string pszDescription;
				public Guid fidParent;
				public string pszRelativePath;
				public string pszParsingName;
				public string pszToolTip;
				public string pszLocalizedName;
				public string pszIcon;
				public string pszSecurity;
				public uint dwAttributes;
				public KF_DEFINITION_FLAGS kfdFlags;
				public Guid ftidType;
			}
#pragma warning restore CS0649 //field never assigned
			
			internal enum FFFP_MODE {
				FFFP_EXACTMATCH,
				FFFP_NEARESTPARENTMATCH
			}
			
			[ComImport, Guid("8BE2D872-86AA-4d47-B776-32CCA40C7018"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
			internal unsafe interface IKnownFolderManager {
				[PreserveSig] int FolderIdFromCsidl(int nCsidl, out Guid pfid);
				[PreserveSig] int FolderIdToCsidl(in Guid rfid, out int pnCsidl);
				[PreserveSig] int GetFolderIds(out Guid* ppKFId, out int pCount);
				[PreserveSig] int GetFolder(in Guid rfid, out IKnownFolder ppkf);
				[PreserveSig] int GetFolderByName([In, MarshalAs(UnmanagedType.LPWStr)] string pszCanonicalName, out IKnownFolder ppkf);
				//[PreserveSig] int RegisterFolder(in Guid rfid, in KNOWNFOLDER_DEFINITION pKFD);
				//[PreserveSig] int UnregisterFolder(in Guid rfid);
				//[PreserveSig] int FindFolderFromPath([In, MarshalAs(UnmanagedType.LPWStr)] string pszPath, FFFP_MODE mode, out IKnownFolder ppkf);
				//[PreserveSig] int FindFolderFromIDList(IntPtr pidl, out IKnownFolder ppkf);
				//[PreserveSig] int Redirect(in Guid rfid, wnd hwnd, uint flags, [In, MarshalAs(UnmanagedType.LPWStr)] string pszTargetPath, uint cFolders, [MarshalAs(UnmanagedType.LPArray)] [In] Guid[] pExclusion, char** ppszError);
			}
			
			[ComImport, Guid("4df0c730-df9d-4ae3-9153-aa6b82e9795a"), ClassInterface(ClassInterfaceType.None)]
			internal class KnownFolderManager { }
			
			internal enum KF_CATEGORY {
				KF_CATEGORY_VIRTUAL = 1,
				KF_CATEGORY_FIXED = 2,
				KF_CATEGORY_COMMON = 3,
				KF_CATEGORY_PERUSER = 4
			}
			
			[ComImport, Guid("3AA7AF7E-9B36-420c-A8E3-F77D4674A488"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
			internal unsafe interface IKnownFolder {
				[PreserveSig] int GetId(out Guid pkfid);
				[PreserveSig] int GetCategory(out KF_CATEGORY pCategory);
				[PreserveSig] int GetShellItem(uint dwFlags, in Guid riid, void** ppv);
				[PreserveSig] int GetPath(uint dwFlags, [MarshalAs(UnmanagedType.LPWStr)] out string ppszPath); //tested: .NET correctly calls CoTaskMemFree
				[PreserveSig] int SetPath(uint dwFlags, [In, MarshalAs(UnmanagedType.LPWStr)] string pszPath);
				[PreserveSig] int GetIDList(uint dwFlags, out IntPtr ppidl);
				[PreserveSig] int GetFolderType(out Guid pftid);
				[PreserveSig] int GetRedirectionCapabilities(out uint pCapabilities);
				[PreserveSig] int GetFolderDefinition(out KNOWNFOLDER_DEFINITION pKFD);
			}
		}
		
		#endregion
		
		#region public methods
		
		/// <summary>
		/// Gets canonical names and paths of all known folders, including custom known folders registered by applications.
		/// These names can be used with <see cref="getFolder"/>.
		/// </summary>
		/// <remarks>
		/// Paths of virtual and unavailable folders are returned as <c><![CDATA["<virtual>"]]></c> and <c><![CDATA["<unavailable>"]]></c>.
		/// </remarks>
		public static unsafe Dictionary<string, string> getKnownFolders() {
			var dict = new Dictionary<string, string>();
			
			var man = new _Api.KnownFolderManager() as _Api.IKnownFolderManager;
			Guid* gp = null;
			try {
				if (man.GetFolderIds(out gp, out int nIds) != 0) return null;
				for (int i = 0; i < nIds; i++) {
					_Api.IKnownFolder kf = null;
					try {
						if (man.GetFolder(gp[i], out kf) != 0) continue;
						if (kf.GetFolderDefinition(out var fd) != 0) continue;
						string path = null;
						if (fd.category == _Api.KF_CATEGORY.KF_CATEGORY_VIRTUAL) {
							path = "<virtual>";
						} else {
							if (kf.GetPath(0, out path) != 0) path = "<unavailable>";
						}
						dict.Add(fd.pszName, path);
						//tested: .NET correctly frees struct strings. Don't need FreeKnownFolderDefinitionFields, which is an inline function that calls CoTaskMemFree.
					}
					catch { }
					finally { Api.ReleaseComObject(kf); }
				}
			}
			catch {
				dict = null;
			}
			finally {
				Marshal.FreeCoTaskMem((IntPtr)gp);
				Api.ReleaseComObject(man);
			}
			return dict;
		}
		
		/// <summary>
		/// Gets path of a known folder by its name.
		/// </summary>
		/// <returns><c>null</c> if unavailable.</returns>
		/// <param name="folderName">
		/// Can be:
		/// <br/>• name of a property of this class, like <c>"Documents"</c>, <c>"Temp"</c>, <c>"ThisApp"</c>. The property must return <see cref="FolderPath"/> or <c>string</c>.
		/// <br/>• name of a property of the nested class <see cref="shell"/>, like <c>"shell.ControlPanel"</c>. Gets <c>":: ITEMIDLIST"</c>.
		/// <br/>• known folder canonical name. See <see cref="getKnownFolders"/>. If has prefix <c>"shell."</c>, gets <c>":: ITEMIDLIST"</c>. Much slower, but allows to get paths of folders registered by applications.
		/// </param>
		/// <seealso cref="pathname.expand"/>
		public static FolderPath getFolder(string folderName) {
			if (folderName.NE()) return default;
			bool isVirtual = folderName.Starts("shell.");
			if (isVirtual) folderName = folderName[6..];
			
			//properties of this class
			Type ty = isVirtual ? typeof(shell) : typeof(folders);
			switch (ty.GetProperty(folderName)?.GetValue(null)) {
			case FolderPath fp: return fp;
			case string fp: return new(fp);
			}
			//Using reflection is not the fastest way, but simplest, cannot make bugs, and don't need maintenance. Fast enough.
			
			//default and custom registered known folders by canonical name
			string R = null;
			_Api.IKnownFolderManager man = null; _Api.IKnownFolder kf = null;
			try {
				man = (_Api.IKnownFolderManager)new _Api.KnownFolderManager();
				if (man.GetFolderByName(folderName, out kf) != 0) return default;
				if (isVirtual) {
					if (0 != kf.GetIDList(0, out IntPtr pidl)) return default;
					R = Pidl.ToHexString(pidl);
					Marshal.FreeCoTaskMem(pidl);
				} else {
					if (0 != kf.GetPath(0, out R)) return default;
					R = pathname.expand(R);
				}
				//tested: works in MTA apartment too. And all props.
			}
			catch { }
			finally {
				Api.ReleaseComObject(kf);
				Api.ReleaseComObject(man);
			}
			
			return new(R);
			
			//speed:
			//	The get-property code is 2 times slower than calling properties directly.
			//	The IKnownFolderManager code is 90 times slower than the get-property code.
		}
		
		#endregion
		
		//DON'T: public static class VirtualNAME that returns parsing name, eg "::{CLSID}\...".
		//	Good: native/.NET shellexecute supports it.
		//	Bad: native/.NET shellexecute supports only some. Almost nothing works in a 32-bit process on 64-bit OS; then even cannot convert the string to ITEMIDLIST. Some parsing names have other formats and the API gets wrong parsing names.
		
		//DON'T: The + operator returns FolderPath. Then folders.Desktop + subfolder + file would return "desktop\subfolder\file". Probably not good.
		//CONSIDER: operator / instead of +. Then could do things like 'folders.x / "subfolder" / "file"' and 'f /= "append"'.
		
		/// <summary>
		/// If string starts with a known/special folder path, gets folder name + relative path and returns <c>true</c>.
		/// For example if string is <c>"C:\Windows\System32\notepad.exe"</c>, gets <c>"folders.System"</c> and <c>"notepad.exe"</c>.
		/// </summary>
		/// <param name="path">Any string. Can be <c>null</c>. Case-insensitive. Supports <c>":: ITEMIDLIST"</c> (see <see cref="Pidl.ToHexString"/>).</param>
		/// <param name="folder">Receives special folder string like <c>"folders.System"</c>.</param>
		/// <param name="name">Receives filename or relative path in the folder.</param>
		/// <remarks>
		/// Quite slow first time in process, eg 50 ms, because gets all folder paths. Later uses cached paths.
		/// </remarks>
		/// <seealso cref="pathname.expand"/>
		public static bool unexpandPath(string path, out string folder, out string name) {
			var p = path; folder = name = null;
			if (!p.NE()) {
				p = p.Lower();
				if (p.Starts(":: ")) {
					foreach (var v in _upv.Value) {
						int n = v.path.Length;
						if (p.Starts(v.path)) {
							folder = "folders.shell." + v.name;
							name = path[n..];
							return true;
						}
					}
				} else {
					p = p.Replace('/', '\\');
					foreach (var v in _up.Value) {
						int n = v.path.Length;
						if (p.Starts(v.path) && (p.Length == n || p[n] == '\\')) {
							folder = "folders." + v.name;
							if (p.Length > n) n++;
							name = path[n..];
							return true;
						}
					}
					
					if (ScriptEditor.IsPortable && path.Starts(ThisAppDriveBS, true)) {
						folder = "folders.ThisAppDriveBS";
						name = path[ThisAppDriveBS.Length..];
						return true;
					}
				}
			}
			return false;
		}
		
		/// <summary>
		/// If string starts with a known/special folder path, replaces that part with <c>%folders.FolderName%</c>. Else returns unchanged string.
		/// For example if string is <c>"C:\Windows\System32\notepad.exe"</c>, returns <c>"%folders.System%\notepad.exe"</c>.
		/// </summary>
		/// <param name="path">Any string. Can be <c>null</c>. Case-insensitive. Supports <c>":: ITEMIDLIST"</c> (see <see cref="Pidl.ToHexString"/>).</param>
		public static string unexpandPath(string path) {
			if (unexpandPath(path, out var s1, out var s2)) path = s2.NE() ? $@"%{s1}%" : $@"%{s1}%\{s2}";
			return path;
		}
		
		static readonly Lazy<List<(string path, string name)>> _up = new(() => {
			var a = new List<(string path, string name)>(120); //105
			lock (_lock) {
				var nac = noAutoCreate;
				noAutoCreate = true;
				foreach (var pi in typeof(folders).GetProperties()) {
					if (pi.PropertyType == typeof(FolderPath)
						&& !pi.Name.Starts("ThisApp") //different in processes
						&& pi.GetValue(null) is FolderPath fp) {
						var s = fp.Path;
						if (!s.NE()) a.Add((s.Lower(), pi.Name));
					}
				}
				noAutoCreate = nac;
			}
			a.Sort((s1, s2) => {
				var r = s2.path.Length - s1.path.Length; //prefer longer path, eg C:\A\B to C:\A
				if (r == 0) { //prefer shorter name, eg System to SystemX64
					r = string.CompareOrdinal(s1.path, s2.path); //sorting does not work without this
					if (r == 0 && s1.path == s2.path) r = s1.name.Length - s2.name.Length;
				}
				return r;
			});
			return a;
		});
		
		static readonly Lazy<List<(string path, string name)>> _upv = new(() => {
			var a = new List<(string path, string name)>(30); //22
			foreach (var pi in typeof(folders.shell).GetProperties()) {
				if (pi.PropertyType == typeof(FolderPath) && pi.GetValue(null) is FolderPath fp) {
					var s = fp.Path;
					//print.it(pi.Name, s);
					if (!s.NE()) a.Add((s, pi.Name));
				}
			}
			return a.OrderByDescending(o => o.path.Length).ToList();
		});
		
		/// <summary>
		/// If <i>path</i> starts with one of specified folder paths, replaces that part with the replacements string. Else returns unchanged string.
		/// </summary>
		/// <param name="path">Any string. Can be <c>null</c>. Case-insensitive.</param>
		/// <param name="list">Folder paths and replacement strings.</param>
		/// <example>
		/// <code><![CDATA[
		/// var s = folders.Documents + "file.txt";
		/// //var s = folders.Temp + "file.txt";
		/// print.it(s);
		/// print.it(folders.unexpandPath(s, (folders.Temp, "%temp%"), (folders.Documents, "%folders.Documents%")));
		/// ]]></code>
		/// </example>
		public static string unexpandPath(string path, params (string folder, string replacement)[] list) {
			path = path.Replace('/', '\\');
			foreach (var (f_, repl) in list) {
				var f = f_.Replace('/', '\\');
				if (path.Starts(f, true)) {
					int len = f.Length;
					if (path.Length == len) return repl;
					if (path[len] is not ('\\' or '/') && f[^1] is not ('\\' or '/')) continue;
					return string.Concat(repl, path.AsSpan(len));
				}
			}
			return path;
		}
	}
}

namespace Au.Types {
	/// <summary>
	/// Most functions of <see cref="folders"/> class return a value of this type.
	/// Contains folder path (string) and has operator <c>+</c> to append a string with backslash if need. Has implicit conversions from/to string.
	/// </summary>
	public struct FolderPath {
		readonly string _path;
		public FolderPath(string path) { _path = path; }
		
		public static explicit operator FolderPath(string path) => new(path); //not implicit. Example: var s = "STRING " + folders.ThisApp; // converts "STRING " to FolderPath and result is @"STRING \C:\path"
		public static implicit operator string(FolderPath f) => f._path;
		
		/// <summary>
		/// Returns <see cref="Path"/>.
		/// </summary>
		public override string ToString() => _path;
		
		/// <summary>
		/// Returns the path string. For some folders it can be <c>null</c>.
		/// </summary>
		public string Path => _path;
		
		/// <summary>
		/// Returns the path string. If it is <c>null</c>, throws <see cref="InvalidOperationException"/>.
		/// </summary>
		/// <exception cref="InvalidOperationException"></exception>
		public string PathOrThrow => _path ?? throw new InvalidOperationException("the special folder path is null");
		
		/// <summary>
		/// Returns <c>true</c> if the path is <c>null</c>.
		/// </summary>
		public bool IsNull => _path == null;
		
		/// <summary>
		/// Calls <see cref="pathname.combine"/>.
		/// Example: <c>string s = folders.Desktop + "file.txt";</c>
		/// </summary>
		/// <exception cref="ArgumentException"><i>fp</i> is empty.</exception>
		public static string operator +(FolderPath fp, string append) {
			if (fp._path.NE()) throw new ArgumentException("No folder path.");
			return pathname.combine(fp._path, append);
		}
	}
}
